/**
 * Form validation utilities for App Configuration Modal
 */

import type { AppConfig } from '../../types'
import type { AppConfigFormData, AppConfigFormErrors, ValidationResult } from './types'

/**
 * Convert AppConfig to form data
 */
export function appConfigToFormData(config: AppConfig): AppConfigFormData {
  return {
    name: config.name || '',
    command: config.command || '',
    workingDirectory: config.workingDirectory || '',
    url: config.url || '',
    description: '', // Not in AppConfig yet, placeholder
    thumbnailPath: config.thumbnailPath || '',
    environmentVariables: config.environmentVariables || {},
    autoLaunchBrowser: config.autoLaunchBrowser ?? true,
    browserDelay: config.browserDelay || 0,
    portToCheck: config.portToCheck?.toString() || '',
    portCheckTimeout: config.portCheckTimeout || 30,
    tags: config.tags || [],
  }
}

/**
 * Convert form data to AppConfig
 */
export function formDataToAppConfig(
  formData: AppConfigFormData,
  existingConfig?: AppConfig
): AppConfig {
  const now = new Date().toISOString()
  
  return {
    id: existingConfig?.id || '', // Will be generated by useConfigManager
    name: formData.name.trim(),
    command: formData.command.trim(),
    workingDirectory: formData.workingDirectory.trim() || undefined,
    url: formData.url.trim() || undefined,
    thumbnailPath: formData.thumbnailPath.trim() || undefined,
    environmentVariables: Object.keys(formData.environmentVariables).length > 0 
      ? formData.environmentVariables 
      : undefined,
    autoLaunchBrowser: formData.autoLaunchBrowser,
    browserDelay: formData.browserDelay,
    portToCheck: formData.portToCheck ? parseInt(formData.portToCheck, 10) : undefined,
    portCheckTimeout: formData.portCheckTimeout,
    tags: formData.tags.length > 0 ? formData.tags : undefined,
    createdAt: existingConfig?.createdAt || now,
    updatedAt: now,
  }
}

/**
 * Create empty form data
 */
export function createEmptyFormData(): AppConfigFormData {
  return {
    name: '',
    command: '',
    workingDirectory: '',
    url: '',
    description: '',
    thumbnailPath: '',
    environmentVariables: {},
    autoLaunchBrowser: true,
    browserDelay: 0,
    portToCheck: '',
    portCheckTimeout: 30,
    tags: [],
  }
}

/**
 * Validate form data
 */
export function validateFormData(
  formData: AppConfigFormData,
  isAppNameTaken?: (name: string, excludeId?: string) => boolean,
  excludeId?: string
): ValidationResult {
  const errors: AppConfigFormErrors = {}
  
  // Required field validation
  if (!formData.name.trim()) {
    errors.name = 'App name is required'
  } else if (formData.name.trim().length < 2) {
    errors.name = 'App name must be at least 2 characters'
  } else if (formData.name.trim().length > 50) {
    errors.name = 'App name must be 50 characters or less'
  } else if (isAppNameTaken && isAppNameTaken(formData.name.trim(), excludeId)) {
    errors.name = 'An app with this name already exists'
  }
  
  if (!formData.command.trim()) {
    errors.command = 'Command is required'
  } else if (formData.command.trim().length > 500) {
    errors.command = 'Command must be 500 characters or less'
  }
  
  // Optional field validation
  if (formData.workingDirectory.trim() && !isValidPath(formData.workingDirectory.trim())) {
    errors.workingDirectory = 'Please enter a valid directory path'
  }
  
  if (formData.url.trim() && !isValidUrl(formData.url.trim())) {
    errors.url = 'Please enter a valid URL (e.g., http://localhost:3000)'
  }
  
  if (formData.thumbnailPath.trim() && !isValidImagePath(formData.thumbnailPath.trim())) {
    errors.thumbnailPath = 'Please select a valid image file'
  }
  
  if (formData.browserDelay < 0 || formData.browserDelay > 60) {
    errors.browserDelay = 'Browser delay must be between 0 and 60 seconds'
  }
  
  if (formData.portToCheck.trim()) {
    const port = parseInt(formData.portToCheck.trim(), 10)
    if (isNaN(port) || port < 1 || port > 65535) {
      errors.portToCheck = 'Port must be a number between 1 and 65535'
    }
  }
  
  if (formData.portCheckTimeout < 1 || formData.portCheckTimeout > 300) {
    errors.portCheckTimeout = 'Port check timeout must be between 1 and 300 seconds'
  }
  
  // Validate tags
  if (formData.tags.length > 10) {
    errors.tags = 'Maximum 10 tags allowed'
  }
  
  for (const tag of formData.tags) {
    if (tag.length > 20) {
      errors.tags = 'Each tag must be 20 characters or less'
      break
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  }
}

/**
 * Validate if a string is a valid URL
 */
function isValidUrl(url: string): boolean {
  try {
    new URL(url)
    return true
  } catch {
    return false
  }
}

/**
 * Validate if a string is a valid file path
 */
function isValidPath(path: string): boolean {
  // Basic path validation - more comprehensive validation will be done by backend
  if (!path.trim()) return false
  
  // Check for invalid characters (basic check)
  const invalidChars = /[<>:"|?*]/
  if (invalidChars.test(path)) return false
  
  return true
}

/**
 * Validate if a path looks like an image file
 */
function isValidImagePath(path: string): boolean {
  if (!path.trim()) return false
  
  const imageExtensions = /\.(png|jpg|jpeg|gif|bmp|svg|webp)$/i
  return imageExtensions.test(path)
}

/**
 * Parse tags from a comma-separated string
 */
export function parseTagsFromString(tagsString: string): string[] {
  return tagsString
    .split(',')
    .map(tag => tag.trim())
    .filter(tag => tag.length > 0)
    .slice(0, 10) // Limit to 10 tags
    .map(tag => tag.substring(0, 20)) // Limit each tag to 20 characters
}

/**
 * Format tags array to comma-separated string
 */
export function formatTagsToString(tags: string[]): string {
  return tags.join(', ')
}
